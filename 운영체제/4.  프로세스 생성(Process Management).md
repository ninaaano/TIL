## 프로세스 생성(Process Creation)

- Copy-on-write(COW)
운영체제 및 컴퓨터 시스템에서 메모리 관리 기술 중 하나로, 공유되는 메모리 영역에서의 데이터 복사를 최소화하여 시스템 성능을 향상시키는 방법. 프로세스가 데이터를 수정하려고 할 때만 해당 데이터를 복사하는 방식으로 작동한다. 일반적으로 여러 프로세스가 같은 메모리 영역을 공유할 때, 각 프로세스는 독립적인 가상 주소 공간을 가지지만, 실제로 물리적인 메모리 페이지를 공유할 수 있다. 이 때 COW 기술을 사용하면, 프로세스 중 하나가 해당 메모리 페이지를 수정하려고 할 때만 복사된 개별 메모리 페이지를 할당하고 수정한 데이터를 저장한다. 나머지 프로세스들은 여전히 원래의 메모리 페이지를 공유하게 된다
프로세스 간의 데이터 복사를 최소화하여 프로세스의 작업 부하를 감소시키고, 더 많은 프로세스가 동시에 실행될 수 있는 장점이 있다.
- 부모 프로세스가 자식 프로세스 생성
- 프로세스의 트리(계층 구조)형성
- 프로세스는 자원을 필요로 함
    - 운영체제로부터 받는다
    - 부모와 공유한다
- 자원의 공유
    - 부모와 자식이 모든 자원을 공유하는 모델 → 코드, 데이터, 스택
    - 일부를 공유하는 모델
    - 전혀 공유하지 않는 모델
- 수행(Execution)
    - 부모와 자식은 공존하며 수행되는 모델
    - 자식이 종료(terminate)될 때까지 부모가 기다리는(wait)모델
- 주소 공간(Address space)
    - 자식은 부모의 공간을 복사함(binary and OS data)
    - 자식은 그 공간에 새로운 프로그램을 올림
- 유닉스의 예
    - fork()라고 불리는 시스템 콜이 새로운 프로세스를 생성
        - 포크 호출은 자식 프로세스가 부모를 그대로 복사해서 독립적으로 실행될 수 있는 새로운 프로세스 생성 (OS data except PID + binary)
        - 주소 공간 할당
    - fork 다음에 이어지는 exec() 시스템 콜을 통해 자식 프로세스의 이미지를 로드하여 새로운 프로그램을 메모리에 올린다 → macOS 운영체제

## 프로세스 종료(Process Termination)

- 프로세스가 마지막 명령을 수행한 후 운영체제에게 이를 알려줌 (exit) → 자발적
    - 자식이 부모에게 Output data를 보냄 (via wait)
    - 프로세스의 각종 자원들이 운영체제에게 반납됨
- 부모 프로세스가 자식의 수행을 종료시킴 (abort) → 비자발적
    - 자식이 할당 자원의 한계치를 넘어섬
    - 자식에게 할당된 태스크가 더 이상 필요하지 않음
    - 부모가 종료하는 경우
        - 운영체제는 부모 프로세스가 종료하는 경우 자식이 더 이상 수행되도록 두지 않는다
        - 단계적인 종료

![](https://velog.velcdn.com/images/ninaaano/post/26b4b534-03e9-412e-9652-699ece192954/image.png)


### fork() 시스템 콜

fork()는 유닉스 및 유닉스 기반 운영체제에서 제공하는 시스템 콜 중 하나로, 현재 실행중인 부모 프로세스의 복제본인 자식 프로세스를 생성하는데 사용된다. fork() 시스템 콜은 새로운 프로세스를 생성하여 부모 프로세스의 주소 공간, 파일 디스크립터 등을 복사하여 자식 프로세스를 생성한다

부모의 상태를 자식 프로세스에 복사하는데 데이터는 COW를 이용하여 공유될 수 있다. 즉, 부모 프로세스와 자식 프로세스는 처음에는 같은 주소를 공유하지만, 한 쪽이 해당 주소 공간의 데이터를 수정하려고 할 때 복사된 개별 주소 공간을 할당하고 데이터를 수정한다

### exec() 시스템 콜

유닉스 및 유닉스 기반 운영체제에서 제공하는 시스템 콜 중 하나로, 현재 실행중인 프로세스의 메모리 이미지를 새로운 프로그램으로 덮어쓰는 기능을 수행한다. 이를 통해 현재 실행 중인 프로세스의 프로그램을 다른 프로그램으로 교체할 수 있다

exec() 시스템 콜은 새로운 프로그램을 실행하기 위해 현재 프로세스의 주소 공간, 파일 디스크립터, 환경 변수 등을 새로운 프로그램의 내용으로 덮어쓰는 역할을 수행한다. 이로써 현재 실행중인 프로세스가 완전히 새로운 프로그램을 실행하는 것 처럼 동작하게 된다

exec() 시스템 콜은 주로 프로세스의 새로운 프로그램을 로드하고 실행하기 위해 사용된다. 예를 들어 쉘에서 사용자의 명령을 실행할 때, 쉘 프로세스는 exec() 시스템 콜을 사용하여 해당 명령에 대한 새로운 프로그램을 실행한다. 또한 다양한 프로세스의 동적 로딩, 프로세스 간의 통신을 위한 중재자 프로세스의 역할을 하는 경우에도 exec() 시스템 콜이 사용될 수 있다. 

exec() 시스템 콜은 현재 실행 중인 프로세스의 메모리 이미지를 완전히 교체하기 때문에, 이전의 프로그램이 메모리에서 사라지고 새로운 프로그램이 실행되기 때문에, 현재 프로세스의 상태와 자원들은 초기화되고, 새로운 프로그램이 새로운 진입점(main 함수)에서 실행된다.

### wait() 시스템 콜

- 프로세스 A가 wait() 시스템 콜을 호출하면
    - 커널은 자식이 종료될 때까지 프로세스 A를 sleep 시킨다 (block 상태)
    - Child process가 종료되면 커널은 프로세스 A를 깨운다 (Ready 상태)

wait()는 유닉스 및 유닉스 기반 운영체제에서 제공하는 시스템 콜 중 하나로 부모 프로세스에서 호출되며, 자식 프로세스가 종료될 때까지 블로킹(Block) 상태로 대기한다. 자식 프로세스가 종료되면 부모 프로세스는 해당 자식 프로세스의 종료 상태(exit status)를 확인하고, 자원을 정리하거나 결과를 처리할 수 있다.

### exit() 시스템 콜

유닉스 및 유닉스 기반 운영체제에서 제공하는 시스템 콜 중 하나로, 현재 실행중인 프로세스를 종료하는 기능을 수행한다. exit() 시스템 콜을 호출하면, 현재 실행중인 프로세스는 즉시 종료되며, 해당 프로세스가 사용한 자원은 운영체제에 반환된다. 현재 실행중인 프로세스의 종료를 요청하고, 해당 프로세스가 종료되면 자동으로 시스템에 의해 정리된다. 종료되는 프로세스는 종료상태 값을 반환하며, 이 종료 상태 값은 부모 프로세스가 wait() 시스템 콜을 사용하여 확인할 수 있다. 

- 자발적 종료 : 프로세스가 자발적으로 종료되는 경우
    - 마지막 statement 수행 후 exit() 시스템 콜을 통해 프로그램에 명시적으로 적어주지 않아도 Main 함수가 리턴되는 위치에 컴파일러가 넣어줌
- 비자발적 종료 : 프로세스가 오류 등의 이유로 종료되는 경우
    - 부모 프로세스가 자식 프로세스를 강제 종료 시킨다
        - 자식 프로세스가 한계치를 넘어서는 자원을 요청하거나
        - 자식에게 할당된 태스크가 더 이상 필요하지 않을때
    - 키보드로 kill, break 등을 친 경우
    - 부모가 종료하는 경우
        - 부모 프로세스가 종료하기 전에 자식들이 먼저 종료된다

프로세스가 종료될 때 호출되는 함수인 exit() 함수와는 다르다. exit() 함수는 해당 프로세스를 종료시키기 위해 exit() 시스템 콜을 사용한다. exit() 시스템 콜은 운영체제 수준에서의 기능이며, exit() 함수는 프로그래밍 언어 수준에서의 함수이다.

## 프로세스 간 협력

- 독립적 프로세스(Independent process)
    
    프로세스는 각자의 주소 공간을 가지고 수행되므로 원칙적으로 하나의 프로세스는 다른 프로세스의 수행에 영향을 미치지 못한다
    
- 협력 프로세스 (Cooperating process)
    
    프로세스 협력 메커니즘을 통해 하나의 프로세스가 다른 프로세스의 수행에 영향을 미칠 수 있다
    
- 프로세스 간 협력 메커니즘(IPC : Interprocess Communication)
독립적으로 실행되는 프로세스들이 서로 통신하고 데이터를 주고받는 메커니즘을 의미한다. 프로세스는 독립적으로 실행되는 독립적인 실행 단위로, 각각의 프로세스는 자체적으로 메모리를 할당받아 독립적으로 실행되기 때문에 서로 다른 프로세스들 사이에서는 기본적으로 메모리가 분리되어 있어 직접적으로 데이터를 공유하기가 어렵다.
    
![](https://velog.velcdn.com/images/ninaaano/post/7e6aa15a-b698-4fae-b4bd-897fed3214a0/image.png)

    
- 메세지를 전달하는 방법
    message passing : 커널을 통해 메세지 전달
- 주소 공간을 공유하는 방법
    shared memory : 서로 다른 프로세스 간에도 일부 주소 공간을 공유하게 하는 shared memory 메커니즘이 있음

> thread는 사실상 하나의 프로세스이므로 프로세스 간 협력으로 보기는 어렵지만 동일한 process를 구성하는 thread들 간에는 주소 공간을 공유하므로 협력이 가능하다
> 

### message Passing

- Message System
프로세스 사이에 공유변수를 일체 사용하지 않고 통신하는 시스템
- Direct Communication
통신하려는 프로세스의 이름을 명시적으로 표시한다
- Indirect Communication
mailbox(또는 port)를 통해 메세지를 간접적으로 전달한다