![](https://velog.velcdn.com/images/ninaaano/post/488ac3be-ca7d-4c97-8d7d-4af0bbf425a8/image.png)


cpu는 기계어를 하나씩 읽어서 실행한다

프린터,모니터 아웃풋 디바이스

- 하드디스크는 IO디바이스라고도 볼 수 있다. 데이터를 읽어서 메모리를 읽어들이기도하고(인풋 디바이스) 처리결과를 파일 시스템에 저장하기도 한다 (아웃풋디바이스)

cpu보다 disk는 느리다. 디스크는 디바이스 컨트롤러가 담당한다.cpu는 읽고 실행하는 역할.

키보드에서 입력이 들어옴, 디스크에서 뭔가를 읽는다는걸 cpu가 어떻게 아느냐? 인터럽트 라인으로 알 수 있다

cpu는 디바이스에 직접적으로 접근하지않고 메모리에만 접근해서 인스트럭션을 실행한다

디스크에서 요청은 어떻게 보내냐? cpu가 디스크 컨트롤러에게 일을 시킨다

1. CPU(Central Processing Unit): 컴퓨터의 중앙 처리 장치로, 기계어 명령어를 하나씩 읽어서 실행하는 역할을 수행합니다.
2. 디바이스: 컴퓨터의 입출력 장치로, 프린터, 모니터 등이 이에 해당합니다. 하드디스크는 입력과 출력을 모두 수행하므로 입출력(IO) 디바이스로 볼 수 있습니다.
3. 디바이스 컨트롤러: 디바이스를 제어하는 하드웨어 장치로, 작은 CPU를 포함하여 디스크의 헤드 움직임 등을 통제합니다. 로컬 버퍼는 디바이스 컨트롤러의 작업 공간을 말합니다.
4. 레지스터: CPU 내에 있는 작은 메모리 공간으로, 메모리보다 빠르게 정보를 저장하고 처리하는 역할을 수행합니다.
5. 모드 빗: CPU에서 실행되는 코드가 운영체제인지 사용자 프로그램인지 구분하는 기능입니다.
6. 인터럽트: 키보드 입력이나 디스크에서 데이터를 읽는 등의 디바이스로부터의 요청을 CPU가 감지하는 신호로, 디바이스 컨트롤러에게 작업을 시키는 역할을 합니다.
7. 인터랙티브 컴퓨팅: CPU가 짧은 간격으로 일을 처리하여 사용자 입장에서는 빠르게 상호작용할 수 있는 컴퓨팅 환경을 말합니다.
8. 타이머: 컴퓨터에 내장된 하드웨어로, 특정 프로그램이 CPU를 독점하는 것을 막기 위해 사용되며, 시스템의 시간 관리 및 스케줄링에 활용됩니다.

### 동작방식

CPU는 기계어를 하나씩 읽어서 실행하는 역할을 합니다. 이때, CPU는 메모리에서 명령어와 데이터를 읽어오고, 실행 결과를 다시 메모리에 저장합니다. CPU가 명령어를 실행할 때, 레지스터라는 공간을 사용합니다. 레지스터는 메모리보다 빠르면서 정보를 저장할 수 있는 작은 공간으로, CPU에서 레지스터를 이용해 데이터를 처리하고 저장합니다.

시스템의 구조와 동작 방식은 크게 운영체제와 응용 프로그램으로 나뉩니다. 운영체제는 하드웨어와 응용 프로그램을 관리하는 소프트웨어입니다. 이를 통해 하드웨어와 응용 프로그램 간의 상호작용을 조정하며, 시스템 자원을 효율적으로 분배합니다. 응용 프로그램은 운영체제 위에서 실행되며, CPU, 메모리, 디스크 등의 자원을 사용하여 작업을 수행합니다.

CPU가 쉬지 않고 일하는 이유는, 컴퓨터 시스템이 짧은 간격으로 일을 처리하기 때문입니다. 이를 통해 사용자는 컴퓨터 시스템과 인터랙티브하게 작업할 수 있습니다. 또한, 컴퓨터 시스템에는 타이머라는 하드웨어가 있으며, 이는 특정 프로그램이 CPU를 독점하는 것을 막기 위해 사용됩니다

### Mode bit

- 사용자 프로그램의 잘못된 수행으로 다른 프로그램 및 운영체제에 피해가 가지 않도록 하기 위한 보호 장치 필요
- Mode bit을 통해 하드웨어적으로 두 가지 모드의 오퍼레이션을 제공한다
    - 1 사용자 모드 : 사용자 프로그램 수행
    - 0 모니터 모드 : OS 코드 수행 ( = 커널 모드, 시스템 모드)
    - 보안을 해칠 수 있는 중요한 명령어는 모니터 모드에서만 수행 가능한 ‘특권 명령’으로 규정
    - Intettupt나 Exception 발생 시 하드웨어가 mode bit을 0으로 바꿈
    - 사용자가 프로그램에게 CPU를 넘기기 전에 mode bit을 1로 셋팅
        
![](https://velog.velcdn.com/images/ninaaano/post/f41d6573-5f70-4626-9b34-84db846de478/image.png)

        

### Timer

- 정해진 시간이 흐른 뒤 운영체제에게 제어권이 넘어가도록 인터럽트를 발생시킨
- 타이머는 매 클럭 틱 때마다 1씩 감소
- 타이머 값이 0이 되면 타이머 인터럽트 발생
- CPU를 특정 프로그램이 독점하는 것으로부터 보호
- 타이머는 시분할을 구현하기 위해 이용된다

### Device controller

- I/O Device Controller
    - 해당 I/O 장치유형을 관리하는 일종의 작은 CPU
    - 제어 정보를 위해 컨트롤 레지스터 , 스테이터스 레지스터를 가진다
    - local buffer를 가진다 (일종의 데이터 레지스터)
- I/O는 실제 디바이스와 로컬 버퍼 사이에서 일어난다
- Device controller는 입출력이 끝났을 경우 인터럽트로 CPU에 그 사실을 알려준다

- device driver(장치 구동기)
    
    OS 코드 중 각 장치별 처리 루틴 → 소프트웨어
    
- device controller(장치제어기)
    
    각 장치를 통제하는 일종의 작은 CPU → 하드웨어
    

### DMA Controller

컴퓨터 시스템에서 데이터를 메인 메모리와 주변 장치 간에 직접 전송하기 위한 하드웨어 장치이다. CPU의 개입 없이 데이터를 주변 장치와 메모리 사이에서 직접 전송하여 시스템의 전송 속도를 향상 시킨다.

DMA 컨트롤러는 주변 장치(예: 하드디스트, 네트워크 카드, 사운드 카드 등)가 데이터를 메모리로 전송하는 동안 CPU를 해방시켜 다른 작업을 수행할 수 있도록 한다. 이는 데이터 전송 속도를 향상 시키고 CPU의 부하를 줄여 시스템 성능을 향상시키는데 도움을 준다

![](https://velog.velcdn.com/images/ninaaano/post/bf0915fd-e2c4-4a95-89bd-75265da7152a/image.png)


### 시스템 콜(system call)

시스템 콜(System Call)은 운영체제에서 제공하는 서비스를 응용 프로그램이 호출하여 사용할 수 있는 인터페이스입니다. 시스템 콜은 응용 프로그램이 커널(Kernel)이라 불리는 운영체제의 핵심 부분에 있는 기능을 사용할 수 있도록 합니다. 응용 프로그램은 시스템 콜을 사용하여 운영체제에게 작업을 요청하고, 운영체제는 이를 처리하여 요청된 작업을 수행한 후 결과를 응용 프로그램에 반환합니다.

시스템 콜은 운영체제가 제공하는 다양한 서비스를 사용할 수 있도록 해줍니다. 예를 들어, 파일 시스템 접근, 프로세스 생성 및 제어, 네트워크 통신, 입출력 장치 관리 등의 작업을 시스템 콜을 통해 수행할 수 있습니다.

시스템 콜의 사용은 일반적으로 고급 언어(C, C++, 자바 등)에서 운영체제의 기능을 호출하는 형태로 이루어집니다. 응용 프로그램은 시스템 콜을 호출하여 운영체제에게 작업을 요청하고, 운영체제는 해당 요청을 처리하여 필요한 동작을 수행한 후, 결과를 응용 프로그램에 반환합니다. 시스템 콜은 운영체제와 응용 프로그램 간의 인터페이스로서 중요한 역할을 수행하며, 운영체제의 기능을 활용하여 다양한 작업을 수행할 수 있게 해줍니다.

### 인터럽트

![](https://velog.velcdn.com/images/ninaaano/post/d00cdfb8-7e49-42d8-a3d7-108fb1d02fee/image.png)


인터럽트(Interrupt)는 컴퓨터 시스템에서 현재 실행 중인 프로그램의 흐름을 중단하고, 특정 이벤트가 발생했을 때 운영체제 또는 하드웨어가 처리해야 하는 작업을 수행하는 기술적인 메커니즘입니다.

인터럽트는 주로 하드웨어 장치나 외부 이벤트가 발생했을 때 사용됩니다. 예를 들어, 키보드나 마우스 입력, 타이머 등의 하드웨어 장치가 데이터를 전송하거나 처리 결과를 알리기 위해 인터럽트를 발생시킬 수 있습니다. 또한, 예외 상황이 발생했을 때(예: 0으로 나누기, 메모리 접근 오류 등) 운영체제가 이를 감지하고 처리하기 위해 인터럽트를 사용할 수도 있습니다.

인터럽트는 현재 실행 중인 프로그램의 흐름을 중단하고, 운영체제 또는 하드웨어가 미리 정의된 처리 루틴(Interrupt Service Routine, ISR)을 실행하여 인터럽트가 발생한 이벤트를 처리합니다. ISR은 해당 인터럽트에 대한 처리를 수행한 후, 원래의 프로그램 실행을 재개하거나 다음에 실행될 프로그램의 주소를 지정하는 등의 작업을 수행합니다.

인터럽트는 시스템의 성능과 안정성을 향상시키는데 중요한 역할을 합니다. 운영체제는 인터럽트를 통해 하드웨어 이벤트를 실시간으로 처리하고, 응용 프로그램은 인터럽트를 통해 운영체제의 서비스를 호출하여 다양한 기능을 사용할 수 있습니다. 인터럽트는 컴퓨터 시스템의 중요한 기술적인 개념이며, 운영체제, 하드웨어, 응용 프로그램 간의 상호작용을 가능하게 합니다.

cpu는 프로그램 카운터라는 레지스터가 가리키는 메모리 주소에서 인스트럭션을 하나 읽어서 실행하는 일만 하게된다. 
다음 인스트럭션을 실행하기전에 인터럽트가 들어온게 있는지 체크한다. 
만약 인터럽트가 들어온게 있다면 지금 프로그램 카운터가 가르키고 있던 걸 중단하고 cpu를 누가 사용하고 있던 상관없이 제어권이 운영체제로 넘어간다. 
운영체제가 cpu를 가지고 있을땐 모드빗이 0이라서 모든 인스트럭션을 다 실행할 수 있다. 
그 중 다른 사용자 프로그램의 메모리 영역을 본다거나, IO디바이스를 접근한다거나 하는 운영체제가 할수있는 인스트럭션으로 정의되어 있다. 
1일땐 사용자 프로그램이 cpu를 가지고 있을때다. 그래서 한정된 인스트럭션만 실행할 수 있는데, 사용자 프로그램을 100% 신뢰할 수 없기때문에 (시스템이 망가진다거나) 자기 주소 메모리 영역에서만 일해야한다. 
IO디바이스에 접근하는 모든 인스트럭션은 모드빗이 0일때 가능하다. 
사용자 프로그램이 운영체제에게 서비스를 요청할땐 시스템 콜을 한다. 
시스템 콜은 어떻게 하느냐? 의도적으로 인터럽트 라인에 세팅을 한다. 
그럼 cpu는 인터럽트 라인이 세팅되었기 때문에 하던 일을 멈추고 cpu 제어권이 사용자 프로그램으로부터 운영체제로 넘어가게 된다. 

## 동기식 입출력과 비동기식 입출력

### 동기식 입출력 (synchronous I/O)

- I/O 요청 후 입출력 작업이 완료된 후에야 제어가 사용자 프로그램에 넘어간다
- 구현 방법 1 → 낭비, 일이 끝날 때까지 기다려야함 (IO낭비)
    - IO가 끝날 때 가지 CPU를 낭비시킴
    - 매 시점 하나의 IO만 일어날  수 있다
- 구현 방법 2
    - IO가 완료될 때까지 해당 프로그램에게서 CPU를 빼앗는다
    - IO처리를 기다리는 줄에 그 프로그램을 줄 세움
    - 다른 프로그램에게 CPU를 준다

### 비동기식 입출력 (asynchronous I/O)

- IO가 시작된 후 입출력 작업이 끝나기를 기다리지않고 제어가 사용자 프로그램에 즉시 넘어간다

> 두 경우 모두 IO의 완료는 인터럽트로 알려준다
> 

![](https://velog.velcdn.com/images/ninaaano/post/fc72546c-50c1-4249-9a01-3c0cacff2e42/image.png)

![](https://velog.velcdn.com/images/ninaaano/post/c14985fa-942d-4eb5-b629-720fbd79a7e6/image.png)

![](https://velog.velcdn.com/images/ninaaano/post/daa93dee-4187-4810-a0c0-2f219eaa9f46/image.png)


- 캐싱? 재사용을 목적으로 한다

### 프로그램이 어떻게 컴퓨터에서 실행이 될까?

![](https://velog.velcdn.com/images/ninaaano/post/93780080-25d5-444e-bc1a-5c5852e27630/image.png)


프로그램은 실행파일로 파일 시스템에 저장되어 있다. 실행 파일을 실행시키면 메모리로 올라가서 프로세스가 된다. 물리적인 메모리에 바로 올라가는 것이 아니라 가상메모리에 먼저 올라간다. 프로세스들은 각자 주소공간을 가지고 있는데, 주소 공간은 0번지부터 시작한다. 주소 공간은 코드, 데이터, 스택 영역으로 이루어져 있다.

- 코드 영역 : cpu에서 실행할 기계어 코드
- 데이터 영역 : 전역 변수, 자료구조
- 스택 : 코드가 함수 구조로 되어있기 때문에 함수를 리턴할 때, 데이터를 쌓았다가 꺼내가는 용도

가상메모리의 주소 공간에서 프로세스가 사용하는 메모리 중 일부만 실제 물리적인 메인 메모리에 올려져 있고, 나머지는 스왑 영역(또는 페이지 파일)으로 저장된다. 이를 페이징이라고 한다.

파일 시스템은 전원이 나가도 파일 내용을 유지가 되지만, 스왑 영역이 있는 하드디스크는 전원이 나가면 내용도 날아간다. 메모리 연장 공간으로써 사용하는 것이 스왑영역이다. 

메모리 주소 변환을 해주는 계층이 있다 → 하드웨어 장치가 있음.

![](https://velog.velcdn.com/images/ninaaano/post/31c6e70c-ef13-422a-9d44-53897b012e49/image.png)


프로세스마다 PCB가 하나씩 만들어져서 관리를 하고있다

![](https://velog.velcdn.com/images/ninaaano/post/c749200e-62ff-4fd0-bb85-c849030d6c7c/image.png)


커널 영역은 운영체제의 핵심 부분으로, 운영체제의 코드, 데이터, 스택 등이 위치하며 시스템 레벨의 권한을 가진 코드가 실행된다. 유저 영역은 사용자 프로세스의 코드, 데이터, 스택 등이 위치하며, 사용자 레벨의 권한을 가진 코드가 실행된다.

커널 영역과 유저 영역은 보안 및 안정성을 위해 분리되어 있다.

유저 영역은 사용자 프로세스들이 실행되는 공간으로, 프로그램 실행에 필요한 데이터, 코드, 스택 등이 위치하며, 사용자 레벨의 권한을 가진 코드가 실행된다. 유저 영역은 사용자 프로세스들이 서로 독립적으로 실행되는 공간이기 때문에, 서로 간 상호작용이나 데이터 공유가 가능하게끔 설계되어 있지만, 유저 영역의 프소세스는 커널 영역의 자원이나 기능에 직접 접근하는 것이 불가능하다.

시스템 콜을 사용하여 운영체제의 기능과 서비스를 호출할 수 있다.

시스템 콜은 사용자 프로세스가 커널 모드로 전환되어 운영 체제의 커널 영역에서 실행되는 함수 호출이다. 사용자 프로세스가 시스템 콜을 호출하면 해당 요청이 운영체제의 커널 영역으로 전달되어, 필요한 작업이 수행되고 그 결과가 사용자 프로세스에 반환된다. 이를 통해 사용자 프로세스는 커널 영역의 주소 공간에 접근하고, 운영체제의 기능을 사용할 수 있다.

---

- 가상메모리
가상메모리는 실제 물리적인 메인 메모리(RAM)와 논리적인 주소 공간을 매핑하여 사용하는 기술. 가상메모리는 프로세스 간에 메모리를 격리하여 보호하고, 물리적인 메모리의 한계를 극복하여 다양한 프로세스를 동시에 실행할 수 있도록 해준다. 가상 메모리는 물리적인 메모리보다 크게 설정할 수 있어, 프로세스가 사용하는 메모리 공간이 실제 메모리보다 큰 경우에도 처리가 가능하게 해준다
    
- 프로세스의 주소 공간
가상 메모리에 있는 논리적인 주소 범위를 말한다. 프로세스는 자신만의 독립적인 가상 주소 공간을 가지며, 이를 통해 각 프로세스는 자신의 가상 주소 공간에서만 주소를 사용하고, 다른 프로세스의 가상 주소 공간에는 접근할 수 없다.
    
- 물리메모리
물리메모리는 컴퓨터의 실제 메인 메모리(RAM)을 의미한다. 컴퓨터의 물리 메모리는 CPU가 직접 접근 가능한 공간으로, 프로세스들이 공유하며, 운영체제와 프로세스들이 메모리를 관리하고 데이터를 주고받는 공간이다
    
- 커널 영역
운영체제의 핵심 부분인 커널이 사용하는 메모리 영역을 말한다. 커널은 운영체제의 핵심기능을 수행하며, 시스템 자원 및 하드웨어를 관리하고 프로세스들을 제어한다. 커널 영역은 프로세스의 주소공간과는 분리되어 있으며, 커널 모드에서만 접근이 가능하며 일반 사용자 모드에서는 접근할 수 없다. 이를 통해 운영체제의 안정성과 보안을 유지하며, 커널에 대한 접근을 제한한다.
    
- PCB(Process Control Block)
운영체제가 프로세스를 관리하기 위해 사용하는 자료구조. 각 프로세스마다 하나의 PCB가 생성되며, 프로세스의 상태 정보와 제어 정보를 저장한다. 프로세스가 다시 실행될 때 저장된 정보를 기반으로 프로세스를 복구하고 계속해서 실행을 진행한다.

1. 프로세스 상태 : 프로세스의 현재 상태. 실행, 준비, 대기중인 상태 등
2. 레지스터 정보 : 프로세스가 현재 사용하고 있는 레지스터의 내용을 저장한다. 예를 들면 프로그램 카운터, 스택 포인터, 베이스 레지스터, 인덱스 레지스터 등
3. 스케줄링 정보 : 프로세스의 우선 순위, CPU 할당 시간 등과 같은 스케줄링 관련 정보
4. 메모리 관리 정보 : 프로세스의 가상 메모리 정보, 페이지 테이블, 메모리 할당 정보 등
5. 입출력 관리 정보 : 프로세스의 입출력 요청 정보, 입출력 버퍼 등
6. 프로세스 식별 장보 : 프로세스의 고유 식별자, 부모 프로세스 식별자 등